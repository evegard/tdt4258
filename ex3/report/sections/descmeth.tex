\section{Description and Methodology}

Roughly, the assignment consisted of three parts: \emph{uploading Linux}
to the microcontroller board, \emph{developing a kernel driver} for the
LEDs and buttons, and \emph{developing a game} utilizing these.

Developing the game was the most time-consuming part of the assignment.
This part consisted of several components that had to be developed. In
addition to the game logic and the user interface, the game needed
support for rendering to the screen, playing sounds, importing images,
reading hardware buttons and controlling LEDs.

\subsection{Installing Linux}

To get Linux to run on the microcontroller, a boot loader is needed in
the Flash memory as the first stage of the booting process. To upload
this boot loader, \texttt{avr32-program} was used as in the previous
assignments.

The boot loader will look for a Linux kernel on the board's memory
card. The memory card thus needs to contain a valid file system, as well
as the root file system for the OS to boot into. This was all supplied
in an image file that was ready to be written to the memory card.
Writing the image file to the card was done using \texttt{dd} on the
lab computer.

\subsection{Developing the kernel driver}

\subsection{Developing the game}

\subsubsection{Sound}
We quickly decided that a sound clip with actual music would sound better than our rendition of ``Itsy Bitsy Spider'', and decided upon the beginning of the Walk√ºrenritt from Richard Wagner's opera Der Ring des Nibelungen, as it sounds sufficiently dramatic. The source file for the sound clip was found in the archives at Textfiles.com, and converted to raw format using Audacity. Audacity was also used to generate sounds where we decided not to use sound clips.

\subsubsection{Graphics}
For our graphics format, we chose uncompressed 24-bit \emph{Truevision TGA} format (also known as TARGA format) for its ease of use and because it is not heavily patented. Truevision TGA is a raster graphics file format. Truevision TGA files have an 18 byte header, of which the last 10 bytes are the image specification. We extracted the image dimensions and format from this to find the exact location and size of the image data, and discarded the other information. We then rendered the raw image data directly. %DERP THIS ISN'T TOO DETAILED HALP.

We encountered one problem: Truevision TGA format is little-endian, and Linux on AVR32 is big-endian. Thankfully, the scope of the problem was limited to the header of the TGA file, as the image data is given in individual bytes. In our case, the only multiple-byte information we needed was the image height and width, both given in two bytes. We solved this by swapping the upper eight and lower eight bits through bit-shifting.
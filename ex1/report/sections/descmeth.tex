\section{Description and methodology}

As described by the task description in the compendium \cite{comp}, a
recommended step-by-step approach to this exercise was as follows:

\begin{enumerate}
    \item Setting up and connecting the STK1000 board.
    \item Downloading the skeleton code and then compiling, uploading
    and debugging this code.
    \item Expanding the skeleton code with code to turn on the LEDs.
    \item Writing code to read the values of the buttons.
    \item Further expanding the program with an interrupt routine.
    \item Modifying the interrupt routine to do the work of reading the
    buttons and changing the LED values accordingly.
\end{enumerate}

This is more or less the approach we went with, with the exception of
writing the interrupt routine before the button handling code.

\subsection{Hardware setup and toolchain usage}

To set up the board, the jumpers were set to their given values and IO
cables were connected to the LED and button pins, all as according to
the compendium. The board was connected to the JTAGICE debugging device
with the appropriate connector, while the JTAGICE in turn was connected
to the computer with a USB cable.

Compiling the skeleton code, and also our own code as the development
progressed, was done using the supplied \emph{makefile} with the
utility \texttt{make}. \texttt{make} then took care of calling the
required programs -- the AS assembler, the LD linker and the
microcontroller programmer utility \texttt{avr32program}.

\subsection{IO setup and LED control}

Our first exercise in the code was to get the LEDs to light up. This
required us to learn the workings of the GPIO model of the STK1000
board.

As instructed by the compendium \cite{comp}, the IO ports are controlled
and accessed by addressing into memory space indicated by the
\texttt{AVR32\_PIOB} and \texttt{AVR32\_PIOC} constants. However, we
quickly realized that these 32-bit addresses would not fit as immediate
values in any instruction for a 32-bit RISC platform.

To accomodate these large addresses, they would need to be stored
together with the program code in the object files and thus in memory
when run, such that they would be accessible at a pre-calculated offset
from the program counter. By labelling the data values in the assembly
code, the compiler would take care of calculating these offsets.

Thus, after having defined the constants with e.g. \texttt{piob: .int
AVR32\_PIOB}, they could then be accessed by using the \texttt{lddpc}
instruction, for instance like this: \texttt{lddpc r0, piob}.
\texttt{lddpc} means to load a value into a register from a memory
location given as a displacement to the program counter \cite{avr32}.

Once the base addresses for the IO control fields were loaded into a
register, the actual setup of the LED IO pins was a matter of storing
the correct values into these fields.

\subsection{Interrupt handling}

Next, we attacked the problem of setting up an interrupt routine. The
compendium contained a thorough description of how this is done
\cite{comp}. The main steps are reiterated here:

\begin{itemize}
    \item Point the \texttt{EVBA} system register to the address of the
    interrupt routine.
    \item Set the \emph{autovector} (offset) for interrupts from PIOB to
    0, as \texttt{EVBA} already points to our desired interrupt routine.
    \item Read PIOB's Interrupt Status Register (\texttt{ISR}) to clear
    any pending interrupts.
    \item Enable interrupts in the CPU using the \texttt{csrf 14}
    instruction (clear CPU status flag 14, which disables interrupts).
\end{itemize}

This was in addition to actually writing the interrupt routine. This
routine in itself was quite straight-forward to implement. We didn't use
any "unsafe" registers, so there was no need to use the stack. The
interrupt routine was thus just a regular routine with a \texttt{rete}
instruction at the end.

\subsection{Responding to buttons}

\input{figures/mainflow}
\input{figures/interruptflow}
\input{figures/registers}

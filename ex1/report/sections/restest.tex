\section{Results and Test}
We did not have a formal testing protocol during this assignment. We completed the code in two stages - one to familiarise ourselves with the function of the LEDs, and one to handle interrupts and button input. 

The first stage consisted of a lot of trial-and-error coding in an attempt to make the row of LEDs cycle, and at what speed. Doing this was a good way to familiarise ourselves with the microcontroller and its quirks, and was a great help later in the assignment. Our practice involved turning the correct LEDs on and off, making sure it looped (using \texttt{rol} to shift the LED along for each loop, and \texttt{ror} to shift it back to the starting point), and making them cycle through all the LEDs at the right speed (using a waiting loop). Testing, here, mainly consisted of changing something, and observing whether the LEDs on the microcontroller behaved correctly. Any errors were rooted out by stepping through the code while observing the LEDs.

The second stage consisted of implementing our interrupts and reading from the buttons. At this point, we took the opportunity to tidy up our code (removing the LED cycle sections) and comment it. We then implemented the interrupts for buttons 0 and 2, testing for which button was pushed and handling the next action accordingly. Again, we had no formal testing structure to test our program, and simply took turns pushing the ``left'' and ``right'' buttons to make sure the LED moved correctly. 

\subsection{Contact bouncing and de-bouncing}
At this point we encountered the problem with {\em contact bouncing}. The actual movement when pushing the button adds noise to the input, and it would make our program behave incorrectly because it was reading the bounce input as actual data. Pushing the button only once could cause the LED to move more than one step in the relevant direction. To prevent this, we delayed reading the input until it had settled, and implemented debouncing in our interrupt handler (see figure \ref{lst:debouncing}). The debouncing mechanism is very simple - it loops 1000 times to force a wait, and by the time the CPU has cycled through, the input has settled to the correct value. At first we tried waiting 100 loops, but still experienced a small degree of bouncing, depending on how we pressed the button. 1000 loops took care of this problem without causing a noticeably delayed response time.

\subsection{Further testing}
After this, we tried testing various button pressing combinations to ensure things worked like they should. Holding a button down for a longer period caused the LED to move only one step in the right direction regardless of holding time, and pressing a button while another was already pressed down produced a result as if the two buttons were pushed in sequence. Pressing two buttons at approximately the same time would cause the LED to move one step in one direction, and one back in quick succession. We also tried pushing a button repeatedly and quickly to see if we could move the LED one step ``too far'' and thereby turn off all the LEDs. This attempt was unsuccessful. For a larger project we would probably need to write a better test protocol, but our program was simple enough for our unstructured tests to indicate that our program worked as desired.

\input{figures/debouncing}
